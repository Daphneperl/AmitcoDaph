<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Elastic ASCII Playground</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=VT323&family=Source+Code+Pro:wght@400;600;700&family=IBM+Plex+Mono:wght@300;400&display=swap');
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: "Source Code Pro", monospace;
      background: #0a0a0a;
      color: #00ff41;
      overflow: hidden;
      height: 100vh;
      display: flex;
    }
    
    /* Split view layout */
    .playground-container {
      display: flex;
      width: 100%;
      height: 100vh;
    }
    
    /* Input Panel */
    .input-panel {
      width: 42%;
      min-width: 420px;
      padding: 20px;
      background: #000;
      border-right: 2px solid #00ff41;
      display: flex;
      flex-direction: column;
      overflow-y: auto;
    }
    
    /* Tab Navigation */
    .tab-container {
      display: flex;
      gap: 5px;
      margin-bottom: 20px;
      border-bottom: 2px solid #00ff41;
      padding-bottom: 10px;
    }
    
    .tab-button {
      flex: 1;
      padding: 10px;
      background: #111;
      color: #888;
      border: 1px solid #333;
      font-family: "Source Code Pro", monospace;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.3s;
      border-bottom: none;
    }
    
    .tab-button.active {
      background: #00ff41;
      color: #000;
      border-color: #00ff41;
      font-weight: bold;
    }
    
    .tab-button:hover:not(.active) {
      background: #222;
      color: #00ff41;
      border-color: #00ff41;
    }
    
    /* Tab Content */
    .tab-content {
      display: none;
      flex: 1;
      flex-direction: column;
    }
    
    .tab-content.active {
      display: flex;
    }
    
    .keyboard-title {
      font-family: "VT323", monospace;
      font-size: 24px;
      margin-bottom: 10px;
      color: #00ff41;
      text-shadow: 0 0 10px #00ff41;
      font-weight: 400;
      letter-spacing: 0.5px;
    }

    .keyboard-ascii {
      font-family: "Source Code Pro", monospace;
      font-size: 12px;
      line-height: 1.15;
      color: #00ff41;
      text-shadow: 0 0 6px rgba(0, 255, 65, 0.6);
      margin-bottom: 20px;
      white-space: pre;
    }
    
    .key {
      display: inline-block;
      transition: transform 0.2s;
    }
    
    .key-space {
      display: inline-block;
      width: 0.3em;
    }
    
    @keyframes pressDown1 {
      30%, 40%, 100% { transform: translateY(0); }
      35% { transform: translateY(8px); }
    }
    
    @keyframes pressDown2 {
      70%, 80%, 100% { transform: translateY(0); }
      75% { transform: translateY(8px); }
    }
    
    @keyframes pressDown3 {
      30%, 40%, 100% { transform: translateY(0); }
      35% { transform: translateY(8px); }
    }
    
    @keyframes pressDown4 {
      40%, 50%, 100% { transform: translateY(0); }
      45% { transform: translateY(8px); }
    }
    
    @keyframes pressDown5 {
      20%, 30%, 100% { transform: translateY(0); }
      25% { transform: translateY(8px); }
    }
    
    @keyframes pressDown6 {
      60%, 70%, 100% { transform: translateY(0); }
      65% { transform: translateY(8px); }
    }
    
    @keyframes pressDown7 {
      10%, 20%, 100% { transform: translateY(0); }
      15% { transform: translateY(8px); }
    }
    
    @keyframes pressDown8 {
      35%, 45%, 100% { transform: translateY(0); }
      40% { transform: translateY(8px); }
    }
    
    @keyframes pressDown9 {
      50%, 60%, 100% { transform: translateY(0); }
      55% { transform: translateY(8px); }
    }
    
    @keyframes pressDown10 {
      25%, 35%, 100% { transform: translateY(0); }
      30% { transform: translateY(8px); }
    }
    
    @keyframes pressDown11 {
      65%, 75%, 100% { transform: translateY(0); }
      70% { transform: translateY(8px); }
    }
    
    @keyframes pressDown12 {
      45%, 55%, 100% { transform: translateY(0); }
      50% { transform: translateY(8px); }
    }
    
    @keyframes pressDown13 {
      15%, 25%, 100% { transform: translateY(0); }
      20% { transform: translateY(8px); }
    }
    
    /* Apply animations to each letter - accounting for spaces at positions 8 and 15 */
    .keyboard-title > .key:nth-child(1) { animation: pressDown1 2s infinite; }
    .keyboard-title > .key:nth-child(2) { animation: pressDown2 3s infinite; }
    .keyboard-title > .key:nth-child(3) { animation: pressDown3 4s infinite; }
    .keyboard-title > .key:nth-child(4) { animation: pressDown4 2.5s infinite; }
    .keyboard-title > .key:nth-child(5) { animation: pressDown5 2.5s infinite; }
    .keyboard-title > .key:nth-child(6) { animation: pressDown6 3.5s infinite; }
    .keyboard-title > .key:nth-child(7) { animation: pressDown7 2.2s infinite; }
    .keyboard-title > .key:nth-child(9) { animation: pressDown8 3.2s infinite; }
    .keyboard-title > .key:nth-child(10) { animation: pressDown9 2.8s infinite; }
    .keyboard-title > .key:nth-child(11) { animation: pressDown10 3.8s infinite; }
    .keyboard-title > .key:nth-child(12) { animation: pressDown11 2.1s infinite; }
    .keyboard-title > .key:nth-child(13) { animation: pressDown12 3.1s infinite; }
    .keyboard-title > .key:nth-child(16) { animation: pressDown13 2.7s infinite; }
    .keyboard-title > .key:nth-child(17) { animation: pressDown1 3.3s infinite; }
    .keyboard-title > .key:nth-child(18) { animation: pressDown2 2.4s infinite; }
    .keyboard-title > .key:nth-child(19) { animation: pressDown3 3.6s infinite; }
    .keyboard-title > .key:nth-child(20) { animation: pressDown4 2.9s infinite; }
    .keyboard-title > .key:nth-child(21) { animation: pressDown5 3.4s infinite; }
    .keyboard-title > .key:nth-child(22) { animation: pressDown6 2.6s infinite; }
    .keyboard-title > .key:nth-child(23) { animation: pressDown7 3.7s infinite; }
    .keyboard-title > .key:nth-child(24) { animation: pressDown8 2.3s infinite; }
    .keyboard-title > .key:nth-child(25) { animation: pressDown9 3.5s infinite; }
    .keyboard-title > .key:nth-child(26) { animation: pressDown10 2.8s infinite; }
    
    .input-panel p {
      font-size: 12px;
      color: #888;
      margin-bottom: 20px;
    }
    
    .input-group {
      margin-bottom: 20px;
    }
    
    .input-group label {
      display: block;
      margin-bottom: 8px;
      font-size: 14px;
      color: #00ff41;
    }
    
    #ascii-input {
      width: 100%;
      height: 300px;
      background: #000;
      color: #00ff41;
      border: 1px solid #00ff41;
      font-family: "Source Code Pro", monospace;
      font-size: 12px;
      padding: 10px;
      resize: vertical;
      caret-color: #00ff41;
    }
    
    #ascii-input:focus {
      outline: none;
      box-shadow: 0 0 10px rgba(0, 255, 65, 0.5);
    }
    
    .button-group {
      display: flex;
      gap: 10px;
      margin-top: 15px;
    }
    
    button {
      flex: 1;
      padding: 12px;
      background: #00ff41;
      color: #000;
      border: none;
      font-family: "Source Code Pro", monospace;
      font-weight: bold;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.3s;
    }
    
    button:hover {
      background: #00cc33;
      box-shadow: 0 0 15px rgba(0, 255, 65, 0.7);
    }
    
    button:active {
      transform: scale(0.98);
    }
    
    button.secondary {
      background: #333;
      color: #00ff41;
    }
    
    button.secondary:hover {
      background: #444;
    }
    
    .info-text {
      font-size: 11px;
      color: #666;
      margin-top: 15px;
      line-height: 1.6;
    }
    
    /* Network View Panel */
    .network-view {
      flex: 1;
      position: relative;
      background: #000;
    }

    .zoom-controls {
      position: absolute;
      top: 20px;
      right: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      z-index: 150;
    }

    .zoom-controls button {
      width: 44px;
      height: 38px;
      border: 1px solid #00ff41;
      background: rgba(0, 0, 0, 0.85);
      color: #00ff41;
      font-family: "Source Code Pro", monospace;
      font-size: 16px;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .zoom-controls button:hover {
      transform: translateY(-2px);
      box-shadow: 0 0 10px rgba(0, 255, 65, 0.6);
    }

    .zoom-controls button:active {
      transform: scale(0.96);
    }

    .zoom-controls button.reset {
      height: 28px;
      font-size: 11px;
      letter-spacing: 0.6px;
    }

    .zoom-indicator {
      width: 44px;
      padding: 4px 0;
      border: 1px solid rgba(0, 255, 65, 0.25);
      background: rgba(0, 0, 0, 0.6);
      color: #00ff41;
      font-family: "Source Code Pro", monospace;
      font-size: 12px;
      text-align: center;
      letter-spacing: 0.5px;
    }
    
    #network-canvas {
      width: 100%;
      height: 100%;
    }
    
    .network-info {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 100;
      background: rgba(0, 0, 0, 0.8);
      padding: 15px;
      border: 1px solid #00ff41;
      border-radius: 4px;
      font-size: 12px;
      color: #00ff41;
      pointer-events: none;
    }
    
    .network-stats {
      position: absolute;
      bottom: 20px;
      left: 20px;
      z-index: 100;
      background: rgba(0, 0, 0, 0.8);
      padding: 15px;
      border: 1px solid #00ff41;
      border-radius: 4px;
      font-size: 12px;
      color: #00ff41;
      pointer-events: none;
    }
    
    /* Responsive */
    @media (max-width: 1024px) {
      .playground-container {
        flex-direction: column;
      }
      
      .input-panel {
        width: 100%;
        min-width: auto;
        height: 40vh;
        border-right: none;
        border-bottom: 2px solid #00ff41;
      }
      
      .network-view {
        height: 60vh;
      }
    }
    
    /* Scrollbar styling */
    .input-panel::-webkit-scrollbar {
      width: 8px;
    }
    
    .input-panel::-webkit-scrollbar-track {
      background: #000;
    }
    
    .input-panel::-webkit-scrollbar-thumb {
      background: #00ff41;
      border-radius: 4px;
    }
    
    .input-panel::-webkit-scrollbar-thumb:hover {
      background: #00cc33;
    }
  </style>
</head>
<body>
  <div class="playground-container">
    <!-- Input Panel -->
    <div class="input-panel">
      <div class="keyboard-title">
        <span class="key">E</span>
        <span class="key">l</span>
        <span class="key">a</span>
        <span class="key">s</span>
        <span class="key">t</span>
        <span class="key">i</span>
        <span class="key">c</span>
        <span class="key-space"> </span>
        <span class="key">A</span>
        <span class="key">S</span>
        <span class="key">C</span>
        <span class="key">I</span>
        <span class="key">I</span>
        <span class="key-space"> </span>
        <span class="key">P</span>
        <span class="key">l</span>
        <span class="key">a</span>
        <span class="key">y</span>
        <span class="key">g</span>
        <span class="key">r</span>
        <span class="key">o</span>
        <span class="key">u</span>
        <span class="key">n</span>
        <span class="key">d</span>
      </div>
      <pre class="keyboard-ascii">
                %%%;       *                      *
   |  %%%;     %%%~%%%;               .                     .     *
 # |__/__%%%____/_/~%;%                           .
     ___%%;______%%;%          .            *            *
" " /~ %-//  \ \__%#%%_-%%;`
   |  ~%-/_%` \ \_/%%#%%`
#  | %%%#%     \__/%%#%%;%`,
  "| ;%%%;`                              *                  .
   |                            *                  (
+| #|            *        .                                          .
  ||         .                        . .        .
   |                .                ` ' `               *
#  |                             .'''. ' .'''.                   *
  "|  *           .                .. ' ' ..      .
'  |                         *    '  '.'.'  '              .
   |                              .'''.'.'''.
 " |       .----------.          ' .''.'.''. '
   |       |__________|            . . : . .
   |_{}_{}/|__________|\{}_{}_{} _'___':'___'_ {}_{}_{}_{}_{}_{}_{}_{}
' #| || ||/____________\|| || ||(_____________)|| || || || || || || ||
lc'\""""""||          ||""""""""""(     )""""""""""""""""""""""""""""
"""""     |            |            _)   (_             .^-^.  ~""~
                         ~""~      (_______)~~"""~~     '._.'
    ~~""~~                     ~""~                     .' '.
                                                        '.,.'
                                                           `'`'
      </pre>
      
      <!-- Tab Navigation -->
      <div class="tab-container">
        <button class="tab-button active" data-tab="converter">Image Converter</button>
        <button class="tab-button" data-tab="manual">Manual Input</button>
      </div>
      
      <!-- Image Converter Tab -->
      <div class="tab-content active" id="converter-tab">
        <div class="input-group">
          <label for="image-upload">Upload Image to Convert:</label>
          <input type="file" id="image-upload" accept="image/*" style="display: none;">
          <div style="display: flex; gap: 10px; margin-bottom: 15px;">
            <button type="button" id="upload-button" class="secondary" style="flex: 1;">Choose Image</button>
            <button type="button" id="convert-button" class="secondary" style="flex: 1;" disabled>Convert to ASCII</button>
          </div>
          
          
          <div id="image-preview" style="margin-top: 15px; display: none;">
            <img id="preview-img" style="max-width: 100%; border: 1px solid #00ff41; display: block; margin-bottom: 10px;">
          </div>
          
          <div id="ascii-preview" style="margin-top: 15px; display: none;">
            <label style="display: block; margin-bottom: 8px; font-size: 14px; color: #00ff41;">Converted ASCII Art:</label>
            <div id="ascii-display" style="background: #000; color: #00ff41; border: 1px solid #00ff41; font-family: 'Source Code Pro', monospace; font-size: 8px; padding: 10px; max-height: 300px; overflow: auto; white-space: pre; line-height: 1.2; letter-spacing: 0px;"></div>
            <textarea id="converted-ascii" readonly style="display: none;"></textarea>
          </div>
        </div>
        
        <div class="button-group" style="margin-top: 15px;">
          <button id="send-to-canvas" style="display: none;">Send to Canvas</button>
          <button id="clear-converter" class="secondary">Clear</button>
        </div>
        
        <div class="info-text" style="margin-top: 15px;">
          <strong>How to use:</strong><br>
          1. Click "Choose Image" and select an image<br>
          2. Click "Convert to ASCII" - image will transform to ASCII<br>
          3. Click "Send to Canvas" to add it to the interactive network
        </div>
      </div>
      
      <!-- Manual Input Tab -->
      <div class="tab-content" id="manual-tab">
        <div class="input-group">
          <label for="ascii-input">Enter your ASCII art:</label>
          <textarea id="ascii-input" placeholder="Paste or type your ASCII art here...

Example:
    +---+
    |   |
    +---+"></textarea>
        </div>
        
        <div class="button-group">
          <button id="add-to-network">Add to Canvas</button>
          <button id="clear-all" class="secondary">Clear All</button>
        </div>
        
        <div class="info-text">
          <strong>Instructions:</strong><br>
          • Enter ASCII art manually and click "Add to Canvas"<br>
          • Drag any character/node to stretch connections<br>
          • Release to let it spring back<br>
          • Press 'R' to reload/parse ASCII<br>
          • Press 'L' to lock/unlock nodes
        </div>
      </div>
    </div>
    
    <!-- Network View Panel -->
    <div class="network-view">
      <div id="network-canvas"></div>
      
      <div class="network-info">
        <div>Stretch your ASCII piece</div>
        <div>release to watch it find its way back</div>
      </div>
      
      <div class="network-stats">
        <div>Nodes: <span id="node-count">0</span></div>
        <div>Connections: <span id="connection-count">0</span></div>
      </div>

      <div class="zoom-controls" aria-label="Zoom controls">
        <button type="button" id="zoom-in" aria-label="Zoom in">+</button>
        <div class="zoom-indicator" id="zoom-indicator">100%</div>
        <button type="button" id="zoom-out" aria-label="Zoom out">&minus;</button>
        <button type="button" id="zoom-reset" class="reset" aria-label="Reset zoom">Reset</button>
      </div>
    </div>
  </div>

  <script>
    // Global variables
    let nodes = [];
    let connections = [];
    let draggedNode = null;
    let isDragging = false;
    let time = 0;
    let currentASCII = "";
    let lockedNodes = new Set();
    let zoomLevel = 1;
    const minZoom = 0.5;
    const maxZoom = 2.5;

    // p5.js sketch
    function setup() {
      const inputPanel = document.querySelector('.input-panel');
      const networkView = document.querySelector('.network-view');
      const canvas = createCanvas(
        networkView.clientWidth,
        networkView.clientHeight
      );
      canvas.parent('#network-canvas');
      
      // Set text properties
      textFont("Source Code Pro");
      
      updateStats();
      updateZoomIndicator();
    }
    
    function draw() {
      background(0);
      time += 0.02;
      
      // Update physics
      updatePhysics();

      push();
      translate(width / 2, height / 2);
      scale(zoomLevel);
      translate(-width / 2, -height / 2);

      // Draw connections
      drawConnections();
      
      // Draw nodes
      drawNodes();
      pop();
    }
    
    function parseASCII(asciiText) {
      nodes = [];
      connections = [];
      lockedNodes.clear();
      
      if (!asciiText || !asciiText.trim()) {
        updateStats();
        return;
      }
      
      let lines = asciiText.trim().split('\n');
      let charSize = 12;
      let lineHeight = 18;
      
      // Calculate center position
      let maxWidth = 0;
      for (let line of lines) {
        if (line.length > maxWidth) maxWidth = line.length;
      }
      
      let centerX = width / 2;
      let centerY = height / 2;
      
      // Create nodes for each character
      for (let y = 0; y < lines.length; y++) {
        let line = lines[y];
        for (let x = 0; x < line.length; x++) {
          let char = line[x];
          if (char !== ' ') {
            let node = {
              id: nodes.length,
              char: char,
              x: centerX - (maxWidth * charSize) / 2 + x * charSize,
              y: centerY - (lines.length * lineHeight) / 2 + y * lineHeight,
              originalX: centerX - (maxWidth * charSize) / 2 + x * charSize,
              originalY: centerY - (lines.length * lineHeight) / 2 + y * lineHeight,
              vx: 0,
              vy: 0,
              isDragged: false
            };
            nodes.push(node);
          }
        }
      }
      
      // Create connections between nearby nodes
      for (let i = 0; i < nodes.length; i++) {
        for (let j = i + 1; j < nodes.length; j++) {
          let node1 = nodes[i];
          let node2 = nodes[j];
          let distance = dist(node1.x, node1.y, node2.x, node2.y);
          
          // Connect nodes that are close to each other (within reasonable distance)
          if (distance < 30) {
            connections.push({
              from: i,
              to: j,
              restLength: distance
            });
          }
        }
      }
      
      // Also connect adjacent characters (neighbors in ASCII grid)
      connectAdjacentNodes(lines, charSize, lineHeight, centerX, centerY);
      
      updateStats();
      console.log("Created", nodes.length, "nodes and", connections.length, "connections");
    }
    
    function connectAdjacentNodes(lines, charSize, lineHeight, centerX, centerY) {
      // Create a map of position to node
      let nodeMap = new Map();
      
      for (let y = 0; y < lines.length; y++) {
        let line = lines[y];
        for (let x = 0; x < line.length; x++) {
          let char = line[x];
          if (char !== ' ') {
            let nodeId = y * lines[0].length + x;
            // Find the actual node
            for (let node of nodes) {
              let expectedX = centerX - (Math.max(...lines.map(l => l.length)) * charSize) / 2 + x * charSize;
              let expectedY = centerY - (lines.length * lineHeight) / 2 + y * lineHeight;
              if (abs(node.x - expectedX) < 1 && abs(node.y - expectedY) < 1) {
                nodeMap.set(`${x},${y}`, node);
                break;
              }
            }
          }
        }
      }
      
      // Connect horizontally and vertically adjacent characters
      for (let y = 0; y < lines.length; y++) {
        let line = lines[y];
        for (let x = 0; x < line.length; x++) {
          let node1 = nodeMap.get(`${x},${y}`);
          if (node1) {
            // Right neighbor
            if (x < line.length - 1 && line[x + 1] !== ' ') {
              let node2 = nodeMap.get(`${x + 1},${y}`);
              if (node2) addConnection(node1, node2);
            }
            // Bottom neighbor
            if (y < lines.length - 1 && x < lines[y + 1].length && lines[y + 1][x] !== ' ') {
              let node2 = nodeMap.get(`${x},${y + 1}`);
              if (node2) addConnection(node1, node2);
            }
            // Diagonal connections (optional, makes it more connected)
            if (y < lines.length - 1 && x < lines[y + 1].length - 1 && lines[y + 1][x + 1] !== ' ') {
              let node2 = nodeMap.get(`${x + 1},${y + 1}`);
              if (node2) addConnection(node1, node2);
            }
            if (y < lines.length - 1 && x > 0 && lines[y + 1][x - 1] !== ' ') {
              let node2 = nodeMap.get(`${x - 1},${y + 1}`);
              if (node2) addConnection(node1, node2);
            }
          }
        }
      }
    }
    
    function addConnection(node1, node2) {
      // Check if connection already exists
      let exists = connections.some(conn => 
        (conn.from === node1.id && conn.to === node2.id) ||
        (conn.from === node2.id && conn.to === node1.id)
      );
      if (!exists) {
        let distance = dist(node1.x, node1.y, node2.x, node2.y);
        connections.push({
          from: node1.id,
          to: node2.id,
          restLength: distance
        });
      }
    }
    
    function updatePhysics() {
      let damping = 0.95;
      let springStrength = 0.1;
      
      // Apply spring forces between connected nodes
      for (let conn of connections) {
        let node1 = nodes[conn.from];
        let node2 = nodes[conn.to];
        
        if (!node1 || !node2) continue;
        
        let dx = node2.x - node1.x;
        let dy = node2.y - node1.y;
        let distance = sqrt(dx * dx + dy * dy);
        
        if (distance > 0) {
          let force = (distance - conn.restLength) * springStrength;
          let fx = (dx / distance) * force;
          let fy = (dy / distance) * force;
          
          if (!node1.isDragged && !lockedNodes.has(node1.id)) {
            node1.vx += fx;
            node1.vy += fy;
          }
          if (!node2.isDragged && !lockedNodes.has(node2.id)) {
            node2.vx -= fx;
            node2.vy -= fy;
          }
        }
      }
      
      // Apply breathing animation (return to original position)
      for (let node of nodes) {
        if (!node.isDragged && !lockedNodes.has(node.id)) {
          // Gentle breathing motion
          let breathX = sin(time + node.id * 0.1) * 2;
          let breathY = cos(time + node.id * 0.1) * 1;
          
          node.vx += (node.originalX + breathX - node.x) * 0.02;
          node.vy += (node.originalY + breathY - node.y) * 0.02;
        }
      }
      
      // Update positions
      for (let node of nodes) {
        if (!node.isDragged && !lockedNodes.has(node.id)) {
          node.vx *= damping;
          node.vy *= damping;
          node.x += node.vx;
          node.y += node.vy;
        }
      }
    }
    
    function drawConnections() {
      stroke(100, 100, 100, 150);
      strokeWeight(0.8);
      for (let conn of connections) {
        let node1 = nodes[conn.from];
        let node2 = nodes[conn.to];
        
        if (node1 && node2) {
          line(node1.x, node1.y, node2.x, node2.y);
        }
      }
    }
    
    function drawNodes() {
      for (let node of nodes) {
        push();
        translate(node.x, node.y);
        
        // Highlight if dragged or locked
        if (node.isDragged) {
          fill(255, 255, 0, 100);
          noStroke();
          circle(0, 0, 20);
        } else if (lockedNodes.has(node.id)) {
          fill(255, 0, 0, 100);
          noStroke();
          circle(0, 0, 18);
        }
        
        // Draw the actual ASCII character
        fill(255);
        textAlign(CENTER, CENTER);
        textSize(12);
        textStyle(BOLD);
        text(node.char, 0, 0);
        pop();
      }
    }
    
    function mousePressed() {
      if (mouseButton === LEFT) {
        const { x: worldX, y: worldY } = screenToWorld(mouseX, mouseY);
        // Find closest node
        let closestNode = null;
        let closestDistance = Infinity;
        
        for (let node of nodes) {
          let distance = dist(worldX, worldY, node.x, node.y);
          if (distance < 20 && distance < closestDistance) {
            closestDistance = distance;
            closestNode = node;
          }
        }
        
        if (closestNode) {
          draggedNode = closestNode;
          closestNode.isDragged = true;
          isDragging = true;
        }
      }
    }
    
    function mouseDragged() {
      if (isDragging && draggedNode) {
        const { x: worldX, y: worldY } = screenToWorld(mouseX, mouseY);
        // Move the dragged node
        draggedNode.x = worldX;
        draggedNode.y = worldY;
        draggedNode.vx = 0;
        draggedNode.vy = 0;
      }
    }
    
    function mouseReleased() {
      if (draggedNode) {
        draggedNode.isDragged = false;
      }
      isDragging = false;
      draggedNode = null;
    }
    
    function keyPressed() {
      if (key === 'r' || key === 'R') {
        if (currentASCII) {
          parseASCII(currentASCII);
        }
      }
      
      if (key === 'l' || key === 'L') {
        // Toggle lock on closest node to mouse
        const { x: worldX, y: worldY } = screenToWorld(mouseX, mouseY);
        let closestNode = null;
        let closestDistance = Infinity;
        
        for (let node of nodes) {
          let distance = dist(worldX, worldY, node.x, node.y);
          if (distance < 50 && distance < closestDistance) {
            closestDistance = distance;
            closestNode = node;
          }
        }
        
        if (closestNode) {
          if (lockedNodes.has(closestNode.id)) {
            lockedNodes.delete(closestNode.id);
          } else {
            lockedNodes.add(closestNode.id);
          }
        }
      }
    }
    
    function windowResized() {
      const networkView = document.querySelector('.network-view');
      resizeCanvas(networkView.clientWidth, networkView.clientHeight);
    }
    
    // Update statistics
    function updateStats() {
      document.getElementById('node-count').textContent = nodes.length;
      document.getElementById('connection-count').textContent = connections.length;
    }

    function screenToWorld(screenX, screenY) {
      return {
        x: (screenX - width / 2) / zoomLevel + width / 2,
        y: (screenY - height / 2) / zoomLevel + height / 2
      };
    }

    function setZoom(level) {
      zoomLevel = Math.max(minZoom, Math.min(maxZoom, level));
      updateZoomIndicator();
    }

    function updateZoomIndicator() {
      const indicator = document.getElementById('zoom-indicator');
      if (indicator) {
        indicator.textContent = `${Math.round(zoomLevel * 100)}%`;
      }
    }
    
    // Image to ASCII conversion
    let uploadedImage = null;
    let imageData = null;
    
    // ASCII character set from dark to light
    const asciiChars = " .:-=+*#%@";
    // Extended set for better detail
    const asciiCharsExtended = " .'`^\",:;Il!i><~+_-?][}{1)(|\\/tfjrxnuvczXYUJCLQ0OZmwqpdbkhao*#MW&8%B@$";
    // Edge-focused set with thin strokes
    const asciiEdgeChars = " .'`^\",:;Il!i|\\/tfjrxnuvczXY";
    
    document.getElementById('upload-button').addEventListener('click', () => {
      document.getElementById('image-upload').click();
    });
    
    document.getElementById('image-upload').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = (event) => {
          const img = new Image();
          img.onload = () => {
            uploadedImage = img;
            imageData = null; // Will be generated on convert
            document.getElementById('preview-img').src = event.target.result;
            document.getElementById('image-preview').style.display = 'block';
            document.getElementById('convert-button').disabled = false;
          };
          img.src = event.target.result;
        };
        reader.readAsDataURL(file);
      }
    });
    
    // Convert image to ASCII
    document.getElementById('convert-button').addEventListener('click', () => {
      if (!uploadedImage) return;
      
      const width = 80;
      const contrast = 1.5;
      const oversampleFactor = 2;
      
      // Calculate height maintaining aspect ratio
      const aspectRatio = uploadedImage.height / uploadedImage.width;
      const height = Math.max(1, Math.floor(width * aspectRatio * 0.5)); // 0.5 because ASCII chars are taller
      
      // Use a higher resolution canvas for richer sampling
      const sampleWidth = width * oversampleFactor;
      const sampleHeight = Math.max(1, height * oversampleFactor);
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = sampleWidth;
      canvas.height = sampleHeight;
      
      // Draw and scale image at higher resolution
      ctx.drawImage(uploadedImage, 0, 0, sampleWidth, sampleHeight);
      const imgData = ctx.getImageData(0, 0, sampleWidth, sampleHeight);
      imageData = imgData;
      
      // Pre-compute brightness map
      const pixelCount = sampleWidth * sampleHeight;
      const brightnessMap = new Float32Array(pixelCount);
      let minBrightness = 1;
      let maxBrightness = 0;
      for (let i = 0; i < pixelCount; i++) {
        const index = i * 4;
        const r = imgData.data[index];
        const g = imgData.data[index + 1];
        const b = imgData.data[index + 2];
        const brightness = (r * 0.299 + g * 0.587 + b * 0.114) / 255;
        brightnessMap[i] = brightness;
        if (brightness < minBrightness) minBrightness = brightness;
        if (brightness > maxBrightness) maxBrightness = brightness;
      }

      const brightnessRange = Math.max(0, maxBrightness - minBrightness);
      if (brightnessRange > 0.05) {
        for (let i = 0; i < pixelCount; i++) {
          brightnessMap[i] = (brightnessMap[i] - minBrightness) / brightnessRange;
        }
      }
      
      // Compute gradient magnitude map (simple Sobel approximation)
      const gradientMap = new Float32Array(pixelCount);
      for (let y = 0; y < sampleHeight; y++) {
        for (let x = 0; x < sampleWidth; x++) {
          const centerIndex = y * sampleWidth + x;
          const left = brightnessMap[y * sampleWidth + Math.max(0, x - 1)];
          const right = brightnessMap[y * sampleWidth + Math.min(sampleWidth - 1, x + 1)];
          const up = brightnessMap[Math.max(0, y - 1) * sampleWidth + x];
          const down = brightnessMap[Math.min(sampleHeight - 1, y + 1) * sampleWidth + x];
          const dx = right - left;
          const dy = down - up;
          gradientMap[centerIndex] = Math.sqrt(dx * dx + dy * dy);
        }
      }
      
      // Convert to ASCII with adaptive character selection
      let asciiArt = '';
      const sampleCount = oversampleFactor * oversampleFactor;
      const gradientThreshold = 0.18;
      const contrastThreshold = 0.05;
      
      for (let y = 0; y < height; y++) {
        let row = '';
        for (let x = 0; x < width; x++) {
          let brightnessSum = 0;
          let brightnessSqSum = 0;
          let gradientSum = 0;
          
          for (let sy = 0; sy < oversampleFactor; sy++) {
            const sampleY = y * oversampleFactor + sy;
            for (let sx = 0; sx < oversampleFactor; sx++) {
              const sampleX = x * oversampleFactor + sx;
              const idx = sampleY * sampleWidth + sampleX;
              const br = brightnessMap[idx];
              brightnessSum += br;
              brightnessSqSum += br * br;
              gradientSum += gradientMap[idx];
            }
          }
          
          const avgBrightness = brightnessSum / sampleCount;
          const variance = brightnessSqSum / sampleCount - avgBrightness * avgBrightness;
          const localContrast = Math.sqrt(Math.max(0, variance));
          const avgGradient = gradientSum / sampleCount;
          
          const contrastFactor = 1 + Math.min(localContrast * 1.5, 0.6);
          let adjustedBrightness = avgBrightness;
          if (contrast !== 1 || contrastFactor !== 1) {
            adjustedBrightness = Math.pow(avgBrightness, 1 / (contrast * contrastFactor));
          }
          adjustedBrightness = Math.max(0, Math.min(1, adjustedBrightness));
          
          let ramp = asciiCharsExtended;
          if (avgGradient > gradientThreshold) {
            ramp = asciiEdgeChars;
          } else if (localContrast > contrastThreshold) {
            ramp = asciiChars;
          }
          const charIndex = Math.floor((1 - adjustedBrightness) * (ramp.length - 1));
          row += ramp[charIndex];
        }
        asciiArt += row + '\n';
      }
      
      // Store ASCII art (hidden textarea for sending)
      document.getElementById('converted-ascii').value = asciiArt;
      
      // Replace image preview with ASCII display
      document.getElementById('image-preview').style.display = 'none';
      document.getElementById('ascii-preview').style.display = 'block';
      document.getElementById('ascii-display').textContent = asciiArt;
      document.getElementById('send-to-canvas').style.display = 'block';
    });
    
    // Tab switching
    document.querySelectorAll('.tab-button').forEach(button => {
      button.addEventListener('click', () => {
        const tabName = button.getAttribute('data-tab');
        
        // Update active tab button
        document.querySelectorAll('.tab-button').forEach(btn => {
          btn.classList.remove('active');
        });
        button.classList.add('active');
        
        // Update active tab content
        document.querySelectorAll('.tab-content').forEach(content => {
          content.classList.remove('active');
        });
        document.getElementById(`${tabName}-tab`).classList.add('active');
      });
    });
    
    // Send converted ASCII to canvas
    document.getElementById('send-to-canvas').addEventListener('click', () => {
      const convertedASCII = document.getElementById('converted-ascii').value.trim();
      if (!convertedASCII) {
        alert('Please convert an image to ASCII first!');
        return;
      }
      
      // Switch to manual tab and put ASCII there
      document.querySelectorAll('.tab-button').forEach(btn => {
        btn.classList.remove('active');
      });
      document.querySelector('[data-tab="manual"]').classList.add('active');
      
      document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.remove('active');
      });
      document.getElementById('manual-tab').classList.add('active');
      
      // Put ASCII in manual input
      document.getElementById('ascii-input').value = convertedASCII;
      
      // Auto-add to canvas
      currentASCII = convertedASCII;
      parseASCII(convertedASCII);
      
      // Clear converter
      document.getElementById('converted-ascii').value = '';
      document.getElementById('ascii-display').textContent = '';
      document.getElementById('image-preview').style.display = 'none';
      document.getElementById('ascii-preview').style.display = 'none';
      document.getElementById('send-to-canvas').style.display = 'none';
      document.getElementById('convert-button').disabled = true;
      uploadedImage = null;
    });
    
    // Clear converter
    document.getElementById('clear-converter').addEventListener('click', () => {
      document.getElementById('converted-ascii').value = '';
      document.getElementById('ascii-display').textContent = '';
      document.getElementById('image-preview').style.display = 'none';
      document.getElementById('ascii-preview').style.display = 'none';
      document.getElementById('convert-button').disabled = true;
      document.getElementById('send-to-canvas').style.display = 'none';
      document.getElementById('image-upload').value = '';
      uploadedImage = null;
      imageData = null;
    });
    
    // Event listeners for UI
    document.getElementById('add-to-network').addEventListener('click', () => {
      const asciiText = document.getElementById('ascii-input').value.trim();
      if (!asciiText) {
        alert('Please enter some ASCII art first!');
        return;
      }
      
      currentASCII = asciiText;
      parseASCII(asciiText);
      document.getElementById('ascii-input').value = '';
    });
    
    document.getElementById('clear-all').addEventListener('click', () => {
      // Clear canvas
      nodes = [];
      connections = [];
      lockedNodes.clear();
      currentASCII = "";
      
      // Clear manual input
      document.getElementById('ascii-input').value = '';
      
      // Clear converter tab
      uploadedImage = null;
      imageData = null;
      document.getElementById('converted-ascii').value = '';
      document.getElementById('ascii-display').textContent = '';
      document.getElementById('image-preview').style.display = 'none';
      document.getElementById('ascii-preview').style.display = 'none';
      document.getElementById('send-to-canvas').style.display = 'none';
      document.getElementById('convert-button').disabled = true;
      document.getElementById('image-upload').value = '';
      
      // Update stats
      updateStats();
    });

    document.getElementById('zoom-in').addEventListener('click', () => {
      setZoom(zoomLevel + 0.2);
    });

    document.getElementById('zoom-out').addEventListener('click', () => {
      setZoom(zoomLevel - 0.2);
    });

    document.getElementById('zoom-reset').addEventListener('click', () => {
      setZoom(1);
    });
  </script>
</body>
</html>



